

#include <mega8.h>
#include <delay.h> 
#include <math.h>
#include <stdio.h> 

//状态值命名                                                            

#define RS485_TX        1          //RS485发送
#define RS485_RX        0          //RS485接收 

#define RS485       PORTD.2     //RS485控制口

static unsigned bit new_command;
static unsigned char uart0_data[10];
static unsigned char quantity;  
bit receive_err;                                //接收错误判断
//*********************************************************************
#pragma warn- 
eeprom unsigned char ID_set;                    //地址码                    
#pragma warn+    

//* CRC低位字节值表
flash unsigned char auchCRCHi[] = 
{ 
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 
0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40 
} ; 

flash unsigned char auchCRCLo[] = 
{ 
0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 
0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 
0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 
0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 
0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 
0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 
0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 
0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 
0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 
0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 
0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 
0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 
0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 
0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 
0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 
0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 
0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 
0x43, 0x83, 0x41, 0x81, 0x80, 0x40 
} ;

//延时                              
//CRC校验
unsigned int crc16(unsigned char *puchMsg, unsigned int usDataLen) 
{ 
    unsigned int uchCRCHi = 0xFF ; //* 高CRC字节初始化 
    unsigned int uchCRCLo = 0xFF ; //* 低CRC 字节初始化 
    unsigned long int uIndex ; //* CRC循环中的索引 
    while (usDataLen--) //* 传输消息缓冲区 
    { 
        uIndex = uchCRCHi ^ *puchMsg++ ; //* 计算CRC 
        uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex] ; 
        uchCRCLo = auchCRCLo[uIndex] ; 
    } 
    return (uchCRCHi << 8 | uchCRCLo) ; 
}//uint16 crc16(uint8 *puchMsg, uint16 usDataLen)
//通信主程序
void uart()
{
unsigned char data_long=0,i,k,temp;
unsigned char uart1_data[131];
unsigned int crc_data,j;
        
RS485=RS485_RX;
if(new_command==ERR)
{
data_long=uart0_data[2]+3;
i=uart0_data[data_long];//LSB
j=uart0_data[(unsigned char)(data_long+1)];//MSB 
uart0_data[data_long]=0;
uart0_data[(unsigned char)(data_long+1)]=0;
j=(j<<8)|(unsigned int)i ;
crc_data=crc16(uart0_data,data_long);
if (j==crc_data){receive_err=OK;}
else {goto outerruart;}
if(receive_err==OK)
    {   
    switch (uart0_data[1])//接收正常，内部执行设置命令
        {
        case 0x41: //设置通信地址
                    break;
        case 0x42: //显示地址
                    break;
        case 0x43: //读系统及告警数据
                    break;
        default:break;
        }
        temp=uart1_data[2]+3;          
        crc_data=crc16(uart1_data,temp);
        RS485=RS485_TX;    
        for(i=0;i<temp;i++)
        {
        putchar(uart1_data[i]);
        #asm("wdr");
        }
        putchar(crc_data);//LSB
        putchar(crc_data>>8);//MSB
        delay_ms(2);
        RS485=RS485_RX;  
        receive_err=ERR;
        new_command=OK;
    }
}
}
//*********************************************************************


//*****************************************************************
interrupt [USART_RXC] void uart_rx_isr(void)
{     
unsigned char t;
t=UDR;                                                   
if(quantity<6&&new_command==OK)
    {   
        uart0_data[quantity]=t;
        if(uart0_data[0]==ID_set||uart0_data[0]==0)//0~4
        {     
        quantity++;
        }
        else{quantity=0;}
        if(quantity>2&&uart0_data[2]>2){quantity=0;}
        if(quantity==(uart0_data[2]+5))//4+1
        { 
        new_command=ERR;
        quantity=0; 
        }
        else {new_command=OK;}
        com_time=0;
    }
}
//*****************************************************************

interrupt [TIM1_OVF] void timer1_ovf_isr(void)
{
// 不分频，中断时长为4毫秒  65535-4000=$f060
TCNT1H=0xf0;
TCNT1L=0x60;  
}

void main(void)
{
unsigned char i;
PORTB=0x00;
DDRB=0xFF;

PORTC=0x00;
DDRC=0xDF;

PORTD=0x00;
DDRD=0x5E;

TCCR0=0x00;
TCNT0=0x00;

TCCR1A=0x00;
TCCR1B=0x02;
TCNT1H=0xd8;
TCNT1L=0xef;
OCR1AH=0x00;
OCR1AL=0xcc;//0x00
OCR1BH=0x00;
OCR1BL=0xe7;//0x00

ASSR=0x00;
TCCR2=0x00;
TCNT2=0x00;
OCR2=0x00;

MCUCR=0x00;

TIMSK=0x04;

UCSRA=0x02;
//UCSRB=0x02;
UCSRB=0x98;//18关  98
UCSRC=0x87;//0x87/
UBRRH=0x00;
UBRRL=0x67;

ACSR=0x80;
SFIOR=0x00;

ADMUX=0x00;

ADCSRA=0xC7;//0xc0;
SFIOR&=0x0F;
SFIOR|=0x90;

//WDTCR=0x1F;
WDTCR=0x0F;    
#asm("cli");
new_command=OK;
receive_err=ERR;
quantity=0;
RS485=RS485_RX;
#asm("sei");
while (1)
    {
    uart();
    };
}
